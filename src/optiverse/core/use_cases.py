from __future__ import annotations

import math
import os
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple

import numpy as np

from .raytracing_math import (
    deg2rad, normalize, reflect_vec, ray_hit_element, ray_hit_curved_element,
    transform_polarization_mirror, transform_polarization_lens,
    transform_polarization_beamsplitter, transform_polarization_waveplate,
    compute_dichroic_reflectance,
    refract_vector_snell, fresnel_coefficients,
    NUMBA_AVAILABLE
)
from .models import OpticalElement, SourceParams, RayPath, Polarization, RefractiveInterface
from .color_utils import qcolor_from_hex, wavelength_to_rgb


def _endpoints(elements: List[OpticalElement]):
    return [(e, e.p1, e.p2) for e in elements]


# ===== PARALLEL RAYTRACING SUPPORT =====

def _trace_single_ray_worker(args):
    """
    Worker function for parallel ray tracing. Must be at module level for pickling.
    
    Args:
        args: Tuple containing (ray_initial_state, element_lists, config)
    
    Returns:
        List[RayPath]: Ray paths generated by this single ray
    """
    ray_state, element_lists, config = args
    
    # Unpack ray initial state
    P_init, V_init, remaining_init, pol_init, wl_init, base_rgb = ray_state
    
    # Unpack element lists (each is a list of (obj, p1, p2) tuples or (p1, p2, interface) for refractive)
    mirrors, lenses, bss, waveplates, dichroics, refractive_interfaces, blocks = element_lists
    
    # Unpack configuration
    max_events = config['max_events']
    EPS_ADV = config['EPS_ADV']
    MIN_I = config['MIN_I']
    
    # Trace this ray
    paths: List[RayPath] = []
    
    # Stack: (points, position, velocity, remaining, last_obj, events, intensity, polarization, wavelength)
    stack: List[Tuple[List[np.ndarray], np.ndarray, np.ndarray, float, object, int, float, Polarization, float]] = []
    stack.append(([P_init.copy()], P_init.copy(), V_init.copy(), remaining_init, None, 0, 1.0, pol_init, wl_init))
    
    while stack:
        pts, P, V, remaining, last_obj, events, I, pol, wl = stack.pop()
        if remaining <= 0 or events >= max_events or I < MIN_I:
            if len(pts) >= 2:
                a = int(255 * max(0.0, min(1.0, I)))
                paths.append(RayPath(pts, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            continue

        nearest = (None, None, None, None, None, None, None, None)  # t,X,kind,obj,t_hat,n_hat,C,L
        vnorm = float(np.linalg.norm(V))

        # Check intersections with all element types
        for obj, A, B in mirrors:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "mirror", obj, t_hat, n_hat, C, L)

        for obj, A, B in lenses:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "lens", obj, t_hat, n_hat, C, L)

        for obj, A, B in bss:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "bs", obj, t_hat, n_hat, C, L)

        for obj, A, B in waveplates:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "waveplate", obj, t_hat, n_hat, C, L)

        for obj, A, B in dichroics:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "dichroic", obj, t_hat, n_hat, C, L)

        # Check absorbers (beam blocks)
        for obj, A, B in blocks:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "block", obj, t_hat, n_hat, C, L)
        
        # Check refractive interfaces
        for A, B, iface in refractive_interfaces:
            # Don't skip based on last_obj for interfaces - allow multiple hits
            
            # Check if this is a curved interface
            is_curved = getattr(iface, 'is_curved', False)
            radius = getattr(iface, 'radius_of_curvature_mm', 0.0)
            
            if is_curved and abs(radius) > 0.1:
                # Curved interface - use ray_hit_curved_element
                # Calculate center of curvature from endpoints and radius
                mid = (A + B) / 2.0
                chord = B - A
                chord_length = float(np.linalg.norm(chord))
                
                if chord_length > 1e-6:
                    # Perpendicular to chord (normalized)
                    perp = np.array([-chord[1], chord[0]]) / chord_length
                    
                    # Distance from midpoint to center
                    r_abs = abs(radius)
                    half_chord = chord_length / 2.0
                    
                    if r_abs >= half_chord:  # Valid circular arc
                        d = math.sqrt(r_abs * r_abs - half_chord * half_chord)
                        
                        # Center position (direction depends on sign of radius)
                        if radius > 0:
                            center = mid + d * perp
                        else:
                            center = mid - d * perp
                        
                        # Use curved intersection
                        res = ray_hit_curved_element(P, V, center, r_abs, A, B)
                    else:
                        # Degenerate case - fall back to flat
                        res = ray_hit_element(P, V, A, B)
                else:
                    # Degenerate case - fall back to flat
                    res = ray_hit_element(P, V, A, B)
            else:
                # Flat interface - use standard ray_hit_element
                res = ray_hit_element(P, V, A, B)
            
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "refractive", iface, t_hat, n_hat, C, L)

        t, X, kind, obj, t_hat, n_hat, C, L = nearest
        if X is None:
            P2 = P + V * (remaining / max(1e-12, vnorm))
            pts2 = pts + [P2.copy()]
            a = int(255 * max(0.0, min(1.0, I)))
            paths.append(RayPath(pts2, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            continue

        step = float(t) * vnorm
        P = X
        pts = pts + [P.copy()]
        remaining -= step

        # Save originals for refractive-side logic before any orientation normalization
        n_hat_orig = n_hat.copy()
        t_hat_orig = t_hat.copy()
        dot_v_n_orig = float(np.dot(V, n_hat_orig))

        # Existing orientation normalization for non-refractive elements
        if float(np.dot(V, n_hat)) < 0:
            n_hat = -n_hat
            t_hat = -t_hat

        if kind == "mirror":
            V2 = normalize(reflect_vec(V, n_hat))
            P2 = P + V2 * EPS_ADV
            pol2 = transform_polarization_mirror(pol, V, n_hat)
            stack.append((pts + [P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue

        if kind == "lens":
            y = float(np.dot(P - C, t_hat))
            a_n = float(np.dot(V, n_hat))
            a_t = float(np.dot(V, t_hat))
            theta_in = math.atan2(a_t, a_n)
            f = float(obj.efl_mm)
            theta_out = theta_in - (y / f) if abs(f) > 1e-12 else theta_in
            Vloc = np.array([math.cos(theta_out), math.sin(theta_out)])
            V2 = normalize(Vloc[0] * n_hat + Vloc[1] * t_hat)
            P2 = P + V2 * EPS_ADV
            pol2 = transform_polarization_lens(pol)
            stack.append((pts + [P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue

        if kind == "bs":
            is_polarizing = getattr(obj, 'is_polarizing', False)
            pbs_axis_deg = getattr(obj, 'pbs_transmission_axis_deg', 0.0)
            
            pol_t, intensity_factor_t = transform_polarization_beamsplitter(
                pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=True
            )
            
            pol_r, intensity_factor_r = transform_polarization_beamsplitter(
                pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=False
            )
            
            if is_polarizing:
                T = intensity_factor_t
                R = intensity_factor_r
            else:
                T = max(0.0, min(1.0, float(obj.split_T) / 100.0))
                R = max(0.0, min(1.0, float(obj.split_R) / 100.0))

            Vt = normalize(V)
            Pt = P + Vt * EPS_ADV
            It = I * T
            if It >= MIN_I:
                stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, obj, events + 1, It, pol_t, wl))

            Vr = normalize(reflect_vec(V, n_hat))
            Pr = P + Vr * EPS_ADV
            Ir = I * R
            if Ir >= MIN_I:
                stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, obj, events + 1, Ir, pol_r, wl))
            continue

        if kind == "waveplate":
            phase_shift_deg = getattr(obj, 'phase_shift_deg', 90.0)
            fast_axis_deg = getattr(obj, 'fast_axis_deg', 0.0)
            
            # Determine forward/backward based on which side ray hits waveplate from
            # Use waveplate's intrinsic orientation angle (not the ray-dependent t_hat!)
            # The waveplate's angle_deg defines its inherent direction in the lab frame
            waveplate_angle_deg = getattr(obj, 'angle_deg', 90.0)
            waveplate_angle_rad = deg2rad(waveplate_angle_deg)
            
            # Compute forward normal (perpendicular to waveplate, 90째 CCW from tangent)
            # For vertical waveplate (90째): normal points LEFT (-1, 0)
            # For horizontal waveplate (0째): normal points UP (0, 1)
            forward_normal = np.array([
                -math.sin(waveplate_angle_rad),
                math.cos(waveplate_angle_rad)
            ])
            
            # Ray hits from forward side if traveling against the normal
            dot_v_n = float(np.dot(V, forward_normal))
            is_forward = dot_v_n < 0  # Traveling against normal = forward
            
            # Create a RayPath for the segment UP TO the waveplate with OLD polarization
            # This ensures the inspect tool shows correct polarization before the waveplate
            if len(pts) >= 2:
                a = int(255 * max(0.0, min(1.0, I)))
                paths.append(RayPath(pts, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            
            # Apply waveplate transformation
            pol2 = transform_polarization_waveplate(pol, phase_shift_deg, fast_axis_deg, is_forward)
            
            # Start a NEW ray segment with the NEW polarization after the waveplate
            V2 = normalize(V)
            P2 = P + V2 * EPS_ADV
            # Start new segment with just P2 (not all previous points)
            stack.append(([P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue
        
        if kind == "dichroic":
            cutoff_wl = getattr(obj, 'cutoff_wavelength_nm', 550.0)
            transition_width = getattr(obj, 'transition_width_nm', 50.0)
            pass_type = getattr(obj, 'pass_type', 'longpass')
            
            if wl > 0:
                R, T = compute_dichroic_reflectance(wl, cutoff_wl, transition_width, pass_type)
            else:
                R, T = 0.5, 0.5
            
            Vt = normalize(V)
            Pt = P + Vt * EPS_ADV
            It = I * T
            if It >= MIN_I:
                stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, obj, events + 1, It, pol, wl))
            
            Vr = normalize(reflect_vec(V, n_hat))
            Pr = P + Vr * EPS_ADV
            Ir = I * R
            if Ir >= MIN_I:
                pol_r = transform_polarization_mirror(pol, V, n_hat)
                stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, obj, events + 1, Ir, pol_r, wl))
            continue

        if kind == "block":
            # Absorber: terminate the ray at hit point (pts already includes P)
            if len(pts) >= 2:
                a = int(255 * max(0.0, min(1.0, I)))
                paths.append(RayPath(pts, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            continue
        
        if kind == "refractive":
            # obj here is actually a RefractiveInterface
            iface = obj
            
            # If this is a beam splitter interface, handle it specially
            if iface.is_beam_splitter:
                # Beam splitter behavior with optional PBS
                is_polarizing = iface.is_polarizing
                pbs_axis_deg = iface.pbs_transmission_axis_deg
                
                pol_t, intensity_factor_t = transform_polarization_beamsplitter(
                    pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=True
                )
                
                pol_r, intensity_factor_r = transform_polarization_beamsplitter(
                    pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=False
                )
                
                if is_polarizing:
                    T = intensity_factor_t
                    R = intensity_factor_r
                else:
                    T = max(0.0, min(1.0, iface.split_T / 100.0))
                    R = max(0.0, min(1.0, iface.split_R / 100.0))
                
                # Transmitted ray (no refraction for beam splitter coating)
                Vt = normalize(V)
                Pt = P + Vt * EPS_ADV
                It = I * T
                if It >= MIN_I:
                    stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, iface, events + 1, It, pol_t, wl))
                
                # Reflected ray
                Vr = normalize(reflect_vec(V, n_hat))
                Pr = P + Vr * EPS_ADV
                Ir = I * R
                if Ir >= MIN_I:
                    stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, iface, events + 1, Ir, pol_r, wl))
                continue
            
            # Regular refractive interface - apply Snell's law and Fresnel equations
            # Determine which direction the ray is traveling using ORIGINAL normal
            if dot_v_n_orig < 0:
                # Ray traveling in direction of original normal (n1 -> n2)
                n1 = iface.n1
                n2 = iface.n2
                n_hat_ref = n_hat_orig
            else:
                # Ray traveling against original normal (n2 -> n1)
                n1 = iface.n2
                n2 = iface.n1
                n_hat_ref = -n_hat_orig
            
            # Apply Snell's law with reference normal
            V_refracted, is_total_reflection = refract_vector_snell(V, n_hat_ref, n1, n2)
            
            if is_total_reflection:
                # Total internal reflection - all light reflects
                Vr = V_refracted
                Pr = P + Vr * EPS_ADV
                pol_r = transform_polarization_mirror(pol, V, n_hat_ref)
                stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, iface, events + 1, I, pol_r, wl))
            else:
                # Partial reflection and transmission - compute Fresnel coefficients
                theta1 = abs(math.acos(max(-1.0, min(1.0, -np.dot(V, n_hat_ref)))))
                R, T = fresnel_coefficients(theta1, n1, n2)
                
                # Transmitted (refracted) ray
                Vt = normalize(V_refracted)
                Pt = P + Vt * EPS_ADV
                It = I * T
                if It >= MIN_I:
                    # Polarization approximately preserved through refraction (simplified)
                    stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, iface, events + 1, It, pol, wl))
                
                # Reflected ray (Fresnel reflection)
                Vr = normalize(reflect_vec(V, n_hat_ref))
                Pr = P + Vr * EPS_ADV
                Ir = I * R
                if Ir >= MIN_I:
                    pol_r = transform_polarization_mirror(pol, V, n_hat_ref)
                    stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, iface, events + 1, Ir, pol_r, wl))
            continue

    return paths


def trace_rays(
    elements: List[OpticalElement],
    sources: List[SourceParams],
    max_events: int = 80,
    parallel: bool = None,
    parallel_threshold: int = 20,
) -> List[RayPath]:
    """
    Trace rays from sources through optical elements.
    
    Performance optimizations:
    - Uses Numba JIT compilation for geometry calculations (2-3x speedup)
    - Uses ThreadPoolExecutor for parallel ray tracing (2-4x speedup on multi-core CPUs)
    - Combined: 4-8x speedup on typical workloads
    
    Args:
        elements: List of optical elements (mirrors, lenses, etc.)
        sources: List of light sources
        max_events: Maximum number of interactions per ray
        parallel: If True, use parallel processing. If None (default), automatically
                 enable only when Numba is available (required for GIL release).
                 If False, always use sequential processing.
        parallel_threshold: Minimum number of total rays to use parallelization.
                          Default is 20. Set to 1 to always parallelize, or very high
                          to effectively disable parallelization.
    
    Returns:
        List of RayPath objects representing traced rays
    
    Note:
        Parallel processing REQUIRES Numba to be effective. Without Numba, the Python
        GIL prevents true parallelism and threading overhead makes it slower.
        
        Install Numba with: pip install numba
        (Requires Python 3.9-3.11; Python 3.12+ not yet supported by Numba)
    """
    # Auto-detect: only enable parallel if Numba is available
    if parallel is None:
        parallel = NUMBA_AVAILABLE
        if not NUMBA_AVAILABLE and parallel:
            # This shouldn't happen with parallel=None, but just in case
            print("Note: Parallel processing disabled (Numba not available)")
    # Prepare element lists
    mirrors = [(e, e.p1, e.p2) for e in elements if e.kind == "mirror"]
    lenses = [(e, e.p1, e.p2) for e in elements if e.kind == "lens"]
    bss = [(e, e.p1, e.p2) for e in elements if e.kind == "bs"]
    waveplates = [(e, e.p1, e.p2) for e in elements if e.kind == "waveplate"]
    dichroics = [(e, e.p1, e.p2) for e in elements if e.kind == "dichroic"]
    blocks = [(e, e.p1, e.p2) for e in elements if e.kind == "block"]
    
    # Refractive interfaces are passed directly as (p1, p2, interface) tuples
    # They are collected separately from refractive objects in the main window
    refractive_interfaces = [(e.p1, e.p2, e) for e in elements if e.kind == "refractive_interface"]
    
    element_lists = (mirrors, lenses, bss, waveplates, dichroics, refractive_interfaces, blocks)
    
    # Configuration
    config = {
        'max_events': max_events,
        'EPS_ADV': 1e-3,
        'MIN_I': 0.02,
    }
    
    # Build ray job list
    ray_jobs = []
    for S in sources:
        base = -deg2rad(S.angle_deg)  # Convert user (CW) to math (CCW) convention
        spread = deg2rad(S.spread_deg)
        
        # Determine wavelength and color
        source_wavelength = S.wavelength_nm if S.wavelength_nm > 0 else 0.0
        
        # Always use color_hex for visualization
        src_col = qcolor_from_hex(S.color_hex)
        base_rgb = (src_col.red(), src_col.green(), src_col.blue())
        
        # Generate ray positions and angles
        ys = [0.0] if (S.n_rays <= 1 or S.size_mm == 0) else list(np.linspace(-S.size_mm/2, S.size_mm/2, S.n_rays))
        if spread == 0 or S.n_rays <= 1:
            angles = [base] * len(ys)
        else:
            fan = np.linspace(-spread, +spread, len(ys))
            angles = [base + a for a in fan]
        
        # Get initial polarization for this source
        initial_pol = S.get_polarization()
        
        # Create a job for each ray
        for i, y0 in enumerate(ys):
            th = angles[i]
            V = np.array([math.cos(th), math.sin(th)], float)
            # Apply offset perpendicular to ray direction (90째 CCW from direction)
            perpendicular = np.array([-math.sin(th), math.cos(th)], float)
            P = np.array([S.x_mm, S.y_mm], float) + y0 * perpendicular
            
            ray_state = (P, V, S.ray_length_mm, initial_pol, source_wavelength, base_rgb)
            ray_jobs.append((ray_state, element_lists, config))
    
    # Decide whether to use parallel processing
    total_rays = len(ray_jobs)
    use_parallel = parallel and total_rays >= parallel_threshold
    
    if use_parallel:
        # Use parallel processing with threading
        # Threading works well here because:
        # 1. Numba JIT-compiled functions release the GIL
        # 2. NumPy operations release the GIL
        # 3. Much lower overhead than multiprocessing
        try:
            # Determine number of workers (use all available CPU cores)
            num_workers = os.cpu_count() or 4
            
            with ThreadPoolExecutor(max_workers=num_workers) as executor:
                results = executor.map(_trace_single_ray_worker, ray_jobs)
            
            # Flatten results
            paths: List[RayPath] = []
            for ray_paths in results:
                paths.extend(ray_paths)
            
            return paths
        except Exception as e:
            # If parallel processing fails, fall back to sequential
            print(f"Warning: Parallel raytracing failed ({e}), falling back to sequential processing")
            use_parallel = False
    
    if not use_parallel:
        # Sequential processing (original behavior)
        paths: List[RayPath] = []
        for job in ray_jobs:
            ray_paths = _trace_single_ray_worker(job)
            paths.extend(ray_paths)
        return paths


