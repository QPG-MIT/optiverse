from __future__ import annotations

import math
import os
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple

import numpy as np

from .geometry import (
    deg2rad, normalize, reflect_vec, ray_hit_element,
    transform_polarization_mirror, transform_polarization_lens,
    transform_polarization_beamsplitter, transform_polarization_waveplate,
    compute_dichroic_reflectance,
    NUMBA_AVAILABLE
)
from .models import OpticalElement, SourceParams, RayPath, Polarization
from .color_utils import qcolor_from_hex, wavelength_to_rgb


def _endpoints(elements: List[OpticalElement]):
    return [(e, e.p1, e.p2) for e in elements]


# ===== PARALLEL RAYTRACING SUPPORT =====

def _trace_single_ray_worker(args):
    """
    Worker function for parallel ray tracing. Must be at module level for pickling.
    
    Args:
        args: Tuple containing (ray_initial_state, element_lists, config)
    
    Returns:
        List[RayPath]: Ray paths generated by this single ray
    """
    ray_state, element_lists, config = args
    
    # Unpack ray initial state
    P_init, V_init, remaining_init, pol_init, wl_init, base_rgb = ray_state
    
    # Unpack element lists (each is a list of (obj, p1, p2) tuples)
    mirrors, lenses, bss, waveplates, dichroics = element_lists
    
    # Unpack configuration
    max_events = config['max_events']
    EPS_ADV = config['EPS_ADV']
    MIN_I = config['MIN_I']
    
    # Trace this ray
    paths: List[RayPath] = []
    
    # Stack: (points, position, velocity, remaining, last_obj, events, intensity, polarization, wavelength)
    stack: List[Tuple[List[np.ndarray], np.ndarray, np.ndarray, float, object, int, float, Polarization, float]] = []
    stack.append(([P_init.copy()], P_init.copy(), V_init.copy(), remaining_init, None, 0, 1.0, pol_init, wl_init))
    
    while stack:
        pts, P, V, remaining, last_obj, events, I, pol, wl = stack.pop()
        if remaining <= 0 or events >= max_events or I < MIN_I:
            if len(pts) >= 2:
                a = int(255 * max(0.0, min(1.0, I)))
                paths.append(RayPath(pts, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            continue

        nearest = (None, None, None, None, None, None, None, None)  # t,X,kind,obj,t_hat,n_hat,C,L
        vnorm = float(np.linalg.norm(V))

        # Check intersections with all element types
        for obj, A, B in mirrors:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "mirror", obj, t_hat, n_hat, C, L)

        for obj, A, B in lenses:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "lens", obj, t_hat, n_hat, C, L)

        for obj, A, B in bss:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "bs", obj, t_hat, n_hat, C, L)

        for obj, A, B in waveplates:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "waveplate", obj, t_hat, n_hat, C, L)

        for obj, A, B in dichroics:
            if last_obj is obj:
                continue
            res = ray_hit_element(P, V, A, B)
            if res is None:
                continue
            t, X, t_hat, n_hat, C, L = res
            if t * vnorm > remaining:
                continue
            if nearest[0] is None or t < nearest[0]:
                nearest = (t, X, "dichroic", obj, t_hat, n_hat, C, L)

        t, X, kind, obj, t_hat, n_hat, C, L = nearest
        if X is None:
            P2 = P + V * (remaining / max(1e-12, vnorm))
            pts2 = pts + [P2.copy()]
            a = int(255 * max(0.0, min(1.0, I)))
            paths.append(RayPath(pts2, (base_rgb[0], base_rgb[1], base_rgb[2], a), pol, wl))
            continue

        step = float(t) * vnorm
        P = X
        pts = pts + [P.copy()]
        remaining -= step

        if float(np.dot(V, n_hat)) < 0:
            n_hat = -n_hat
            t_hat = -t_hat

        if kind == "mirror":
            V2 = normalize(reflect_vec(V, n_hat))
            P2 = P + V2 * EPS_ADV
            pol2 = transform_polarization_mirror(pol, V, n_hat)
            stack.append((pts + [P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue

        if kind == "lens":
            y = float(np.dot(P - C, t_hat))
            a_n = float(np.dot(V, n_hat))
            a_t = float(np.dot(V, t_hat))
            theta_in = math.atan2(a_t, a_n)
            f = float(obj.efl_mm)
            theta_out = theta_in - (y / f) if abs(f) > 1e-12 else theta_in
            Vloc = np.array([math.cos(theta_out), math.sin(theta_out)])
            V2 = normalize(Vloc[0] * n_hat + Vloc[1] * t_hat)
            P2 = P + V2 * EPS_ADV
            pol2 = transform_polarization_lens(pol)
            stack.append((pts + [P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue

        if kind == "bs":
            is_polarizing = getattr(obj, 'is_polarizing', False)
            pbs_axis_deg = getattr(obj, 'pbs_transmission_axis_deg', 0.0)
            
            pol_t, intensity_factor_t = transform_polarization_beamsplitter(
                pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=True
            )
            
            pol_r, intensity_factor_r = transform_polarization_beamsplitter(
                pol, V, n_hat, t_hat, is_polarizing, pbs_axis_deg, is_transmitted=False
            )
            
            if is_polarizing:
                T = intensity_factor_t
                R = intensity_factor_r
            else:
                T = max(0.0, min(1.0, float(obj.split_T) / 100.0))
                R = max(0.0, min(1.0, float(obj.split_R) / 100.0))

            Vt = normalize(V)
            Pt = P + Vt * EPS_ADV
            It = I * T
            if It >= MIN_I:
                stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, obj, events + 1, It, pol_t, wl))

            Vr = normalize(reflect_vec(V, n_hat))
            Pr = P + Vr * EPS_ADV
            Ir = I * R
            if Ir >= MIN_I:
                stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, obj, events + 1, Ir, pol_r, wl))
            continue

        if kind == "waveplate":
            phase_shift_deg = getattr(obj, 'phase_shift_deg', 90.0)
            fast_axis_deg = getattr(obj, 'fast_axis_deg', 0.0)
            
            pol2 = transform_polarization_waveplate(pol, phase_shift_deg, fast_axis_deg)
            
            V2 = normalize(V)
            P2 = P + V2 * EPS_ADV
            stack.append((pts + [P2.copy()], P2.copy(), V2, remaining - EPS_ADV, obj, events + 1, I, pol2, wl))
            continue
        
        if kind == "dichroic":
            cutoff_wl = getattr(obj, 'cutoff_wavelength_nm', 550.0)
            transition_width = getattr(obj, 'transition_width_nm', 50.0)
            pass_type = getattr(obj, 'pass_type', 'longpass')
            
            if wl > 0:
                R, T = compute_dichroic_reflectance(wl, cutoff_wl, transition_width, pass_type)
            else:
                R, T = 0.5, 0.5
            
            Vt = normalize(V)
            Pt = P + Vt * EPS_ADV
            It = I * T
            if It >= MIN_I:
                stack.append((pts + [Pt.copy()], Pt.copy(), Vt, remaining - EPS_ADV, obj, events + 1, It, pol, wl))
            
            Vr = normalize(reflect_vec(V, n_hat))
            Pr = P + Vr * EPS_ADV
            Ir = I * R
            if Ir >= MIN_I:
                pol_r = transform_polarization_mirror(pol, V, n_hat)
                stack.append((pts + [Pr.copy()], Pr.copy(), Vr, remaining - EPS_ADV, obj, events + 1, Ir, pol_r, wl))
            continue

    return paths


def trace_rays(
    elements: List[OpticalElement],
    sources: List[SourceParams],
    max_events: int = 80,
    parallel: bool = None,
    parallel_threshold: int = 20,
) -> List[RayPath]:
    """
    Trace rays from sources through optical elements.
    
    Performance optimizations:
    - Uses Numba JIT compilation for geometry calculations (2-3x speedup)
    - Uses ThreadPoolExecutor for parallel ray tracing (2-4x speedup on multi-core CPUs)
    - Combined: 4-8x speedup on typical workloads
    
    Args:
        elements: List of optical elements (mirrors, lenses, etc.)
        sources: List of light sources
        max_events: Maximum number of interactions per ray
        parallel: If True, use parallel processing. If None (default), automatically
                 enable only when Numba is available (required for GIL release).
                 If False, always use sequential processing.
        parallel_threshold: Minimum number of total rays to use parallelization.
                          Default is 20. Set to 1 to always parallelize, or very high
                          to effectively disable parallelization.
    
    Returns:
        List of RayPath objects representing traced rays
    
    Note:
        Parallel processing REQUIRES Numba to be effective. Without Numba, the Python
        GIL prevents true parallelism and threading overhead makes it slower.
        
        Install Numba with: pip install numba
        (Requires Python 3.9-3.11; Python 3.12+ not yet supported by Numba)
    """
    # Auto-detect: only enable parallel if Numba is available
    if parallel is None:
        parallel = NUMBA_AVAILABLE
        if not NUMBA_AVAILABLE and parallel:
            # This shouldn't happen with parallel=None, but just in case
            print("Note: Parallel processing disabled (Numba not available)")
    # Prepare element lists
    mirrors = [(e, e.p1, e.p2) for e in elements if e.kind == "mirror"]
    lenses = [(e, e.p1, e.p2) for e in elements if e.kind == "lens"]
    bss = [(e, e.p1, e.p2) for e in elements if e.kind == "bs"]
    waveplates = [(e, e.p1, e.p2) for e in elements if e.kind == "waveplate"]
    dichroics = [(e, e.p1, e.p2) for e in elements if e.kind == "dichroic"]
    
    element_lists = (mirrors, lenses, bss, waveplates, dichroics)
    
    # Configuration
    config = {
        'max_events': max_events,
        'EPS_ADV': 1e-3,
        'MIN_I': 0.02,
    }
    
    # Build ray job list
    ray_jobs = []
    for S in sources:
        base = deg2rad(S.angle_deg)
        spread = deg2rad(S.spread_deg)
        
        # Determine wavelength and color
        source_wavelength = S.wavelength_nm if S.wavelength_nm > 0 else 0.0
        
        # Always use color_hex for visualization
        src_col = qcolor_from_hex(S.color_hex)
        base_rgb = (src_col.red(), src_col.green(), src_col.blue())
        
        # Generate ray positions and angles
        ys = [0.0] if (S.n_rays <= 1 or S.size_mm == 0) else list(np.linspace(-S.size_mm/2, S.size_mm/2, S.n_rays))
        if spread == 0 or S.n_rays <= 1:
            angles = [base] * len(ys)
        else:
            fan = np.linspace(-spread, +spread, len(ys))
            angles = [base + a for a in fan]
        
        # Get initial polarization for this source
        initial_pol = S.get_polarization()
        
        # Create a job for each ray
        for i, y0 in enumerate(ys):
            P = np.array([S.x_mm, S.y_mm + y0], float)
            th = angles[i]
            V = np.array([math.cos(th), math.sin(th)], float)
            
            ray_state = (P, V, S.ray_length_mm, initial_pol, source_wavelength, base_rgb)
            ray_jobs.append((ray_state, element_lists, config))
    
    # Decide whether to use parallel processing
    total_rays = len(ray_jobs)
    use_parallel = parallel and total_rays >= parallel_threshold
    
    if use_parallel:
        # Use parallel processing with threading
        # Threading works well here because:
        # 1. Numba JIT-compiled functions release the GIL
        # 2. NumPy operations release the GIL
        # 3. Much lower overhead than multiprocessing
        try:
            # Determine number of workers (use all available CPU cores)
            num_workers = os.cpu_count() or 4
            
            with ThreadPoolExecutor(max_workers=num_workers) as executor:
                results = executor.map(_trace_single_ray_worker, ray_jobs)
            
            # Flatten results
            paths: List[RayPath] = []
            for ray_paths in results:
                paths.extend(ray_paths)
            
            return paths
        except Exception as e:
            # If parallel processing fails, fall back to sequential
            print(f"Warning: Parallel raytracing failed ({e}), falling back to sequential processing")
            use_parallel = False
    
    if not use_parallel:
        # Sequential processing (original behavior)
        paths: List[RayPath] = []
        for job in ray_jobs:
            ray_paths = _trace_single_ray_worker(job)
            paths.extend(ray_paths)
        return paths


